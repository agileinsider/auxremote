<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MountService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">auxremote</a> &gt; <a href="index.source.html" class="el_package">com.bobs.mount</a> &gt; <span class="el_source">MountService.java</span></div><h1>MountService.java</h1><pre class="source lang-java linenums">package com.bobs.mount;

import static com.bobs.coord.CoordTransformer.ONE_DEG_IN_HOURS;

import java.util.Calendar;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import com.bobs.coord.CoordTransformer;
import com.bobs.coord.Target;
import com.bobs.io.NexstarAuxAdapter;
import com.bobs.io.NexstarAuxSerialAdapter;
import com.bobs.serialcommands.EnableCordWrap;
import com.bobs.serialcommands.Goto;
import com.bobs.serialcommands.GpsLat;
import com.bobs.serialcommands.GpsLinked;
import com.bobs.serialcommands.GpsLon;
import com.bobs.serialcommands.MountCommand;
import com.bobs.serialcommands.Move;
import com.bobs.serialcommands.PecPlayback;
import com.bobs.serialcommands.PecQueryAtIndex;
import com.bobs.serialcommands.PecQueryRecordDone;
import com.bobs.serialcommands.PecSeekIndex;
import com.bobs.serialcommands.PecStartRecording;
import com.bobs.serialcommands.PecStopRecording;
import com.bobs.serialcommands.QueryAltMcPosition;
import com.bobs.serialcommands.QueryAzMcPosition;
import com.bobs.serialcommands.QueryCordWrap;
import com.bobs.serialcommands.QueryCordWrapPos;
import com.bobs.serialcommands.QuerySlewDone;
import com.bobs.serialcommands.SetAltMcPosition;
import com.bobs.serialcommands.SetAzMcPosition;
import com.bobs.serialcommands.SetGuideRate;

/**
 * Responsible for interacting with the mount using a {@link NexstarAuxSerialAdapter}
 * and providing high level features by means of various {@link MountCommand}s
 */
@Service
<span class="fc" id="L46">public class MountService {</span>

<span class="fc" id="L48">    private static final Logger LOGGER = LoggerFactory.getLogger(MountService.class);</span>
    private static final int DEFAULT_PEC_POLL_INTERVAL = 5000;

    /**
     * This is the mount that the service is managing. There is only 1 mount instance.
     */
    @Autowired
    private Mount mount;

    @Autowired
    private NexstarAuxAdapter auxAdapter;

<span class="fc" id="L60">    private int pecPollInterval = DEFAULT_PEC_POLL_INTERVAL;</span>

    /**
     * The Sync operation is basically 'alignment'. It tells the mount where it is currently pointing.
     * This is used when unparking a mount or when using astrometric plate solving to perform alignment.
     *
     * @param target The Target contining the RA/DEC coordinates to sync to.
     */
    @Async
    public void sync(Target target) {
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (!mount.isLocationSet()) {</span>
<span class="nc" id="L71">            throw new IllegalStateException(&quot;Mount location is not set. Please connect GPS or set location&quot;);</span>
        }
<span class="fc" id="L73">        LOGGER.info(&quot;Syncing to RA:{} DEC:{}&quot;, target.getRaHours(), target.getDec());</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (mount.getTrackingState().equals(TrackingState.IDLE)) {</span>
<span class="nc" id="L75">            startTracking();</span>
        }
<span class="fc" id="L77">        CoordTransformer coordTransformer = new CoordTransformer();</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">        if (mount.getTrackingMode().equals(TrackingMode.EQ_NORTH)) {</span>
<span class="fc" id="L79">            double azimuthAxisDegrees = coordTransformer.convertRaFromDegToNexstarAzimuthAngle(</span>
<span class="fc" id="L80">                    Calendar.getInstance(),</span>
<span class="fc" id="L81">                    mount.getLongitude(),</span>
<span class="fc" id="L82">                    coordTransformer.convertRaHoursToDeg(target.getRaHours()));</span>
<span class="fc" id="L83">            double altitudeAxisDegrees = coordTransformer.convertDecToPositionAngleForEqNorth(target.getDec());</span>
<span class="fc" id="L84">            auxAdapter.queueCommand(new SetAltMcPosition(mount, altitudeAxisDegrees));</span>
<span class="fc" id="L85">            auxAdapter.queueCommand(new SetAzMcPosition(mount, azimuthAxisDegrees));</span>
<span class="fc" id="L86">        } else {</span>
<span class="nc" id="L87">            throw new IllegalStateException(&quot;ONly EQ north tracking mode supported&quot;);</span>
        }
<span class="fc" id="L89">        queryMountState();</span>
<span class="fc" id="L90">        mount.setAligned(true);</span>
<span class="fc" id="L91">    }</span>

    /**
     * Slew the mount to a new position. If the target location is less than 1deg (approx) from the current location
     * then a slow slew only is used, otherwise a fast slew followed by a slow slew is used.
     * This is a non blocking operation. Clients should perform regular queries to determine if the slew is complete.
     *
     * @param target The {@link Target} to go to.
     * @param parkSlew if True then the slew is to park the scope
     */
    @Async
    public void slew(Target target, boolean parkSlew) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (!mount.isAligned()) {</span>
<span class="fc" id="L104">            mount.setStatusMessage(&quot;Error: Please sync mount before slewing&quot;);</span>
<span class="fc" id="L105">            throw new IllegalStateException(&quot;Please sync/align the mount before slewing&quot;);</span>
        }
<span class="fc" id="L107">        LOGGER.info(&quot;Slewing to RA:{} DEC:{}&quot;, target.getRaHours(), target.getDec());</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (parkSlew) {</span>
<span class="fc" id="L109">            mount.setTrackingState(TrackingState.PARKING);</span>
        } else {
<span class="fc" id="L111">            mount.setTrackingState(TrackingState.SLEWING);</span>
        }
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (fastSlewRequired(mount, target)) {</span>
<span class="fc" id="L114">            slewAndWait(target, true);</span>
        }
<span class="fc" id="L116">        slewAndWait(target, false);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (parkSlew) {</span>
<span class="fc" id="L118">            mount.setTrackingState(TrackingState.PARKED);</span>
        } else {
<span class="fc" id="L120">            mount.setTrackingState(TrackingState.TRACKING);</span>
        }
<span class="fc" id="L122">    }</span>

    /**
     * Blocking operation to slew and wait until complete.
     * Waits for each axis to complete.
     *
     * @param target the @{link Target} to slew to
     * @param fast   true/false for fast/slow slew
     */
    private void slewAndWait(Target target, boolean fast) {
<span class="fc" id="L132">        mount.setAltSlewInProgress(true);</span>
<span class="fc" id="L133">        mount.setAzSlewInProgress(true);</span>
<span class="fc" id="L134">        CoordTransformer coordTransformer = new CoordTransformer();</span>
<span class="fc" id="L135">        double azimuthAxisDegrees = coordTransformer.convertRaFromDegToNexstarAzimuthAngle(</span>
<span class="fc" id="L136">                mount.getCalendarProvider().provide(),</span>
<span class="fc" id="L137">                mount.getLongitude(),</span>
<span class="fc" id="L138">                coordTransformer.convertRaHoursToDeg(target.getRaHours()));</span>
<span class="fc" id="L139">        double altitudeAxisDegrees = target.getDec();</span>
<span class="fc" id="L140">        LOGGER.debug(&quot;starting slew&quot;);</span>
<span class="fc" id="L141">        auxAdapter.queueCommand(new Goto(mount, altitudeAxisDegrees, Axis.ALT, fast));</span>
<span class="fc" id="L142">        auxAdapter.queueCommand(new Goto(mount, azimuthAxisDegrees, Axis.AZ, fast));</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        while (mount.isSlewing()) {</span>
<span class="fc" id="L144">            LOGGER.debug(&quot;monitoring slew&quot;);</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            if (mount.isAzSlewInProgress()) {</span>
<span class="fc" id="L146">                auxAdapter.queueCommand(new QuerySlewDone(mount, Axis.AZ));</span>
<span class="fc" id="L147">                sleep(500);</span>
            }
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (mount.isAltSlewInProgress()) {</span>
<span class="fc" id="L150">                auxAdapter.queueCommand(new QuerySlewDone(mount, Axis.ALT));</span>
<span class="fc" id="L151">                sleep(500);</span>
            }
<span class="fc" id="L153">            auxAdapter.queueCommand(new QueryAzMcPosition(mount));</span>
<span class="fc" id="L154">            auxAdapter.queueCommand(new QueryAltMcPosition(mount));</span>
<span class="fc" id="L155">            auxAdapter.waitForQueueEmpty();</span>
<span class="fc" id="L156">            enforceSlewLimit();</span>
        }
<span class="fc" id="L158">    }</span>


    /**
     * Enforce an ALT slew limit for the ALT axis to prevent damage.
     * If limit detected then send serial commands to abort any motion
     */
    private void enforceSlewLimit() {
<span class="fc" id="L166">        CoordTransformer coordTransformer = new CoordTransformer();</span>
<span class="fc" id="L167">        coordTransformer.populateAltAzFromRaDec(mount);</span>
<span class="pc bpc" id="L168" title="1 of 4 branches missed.">        if (mount.getAz() != null &amp;&amp; mount.getAlt() &lt; mount.getSlewLimitAlt()) {</span>
<span class="fc" id="L169">            mount.setStatusMessage(&quot;slew limit reached, aborting&quot;);</span>
<span class="fc" id="L170">            auxAdapter.queueCommand(new Move(mount, 0, Axis.ALT, true));</span>
<span class="fc" id="L171">            auxAdapter.queueCommand(new Move(mount, 0, Axis.AZ, true));</span>
<span class="fc" id="L172">            mount.setAltSlewInProgress(false);</span>
<span class="fc" id="L173">            mount.setAzSlewInProgress(false);</span>
<span class="fc" id="L174">            throw new RuntimeException(&quot;Slew Limit Reached&quot;);</span>
        }
<span class="fc" id="L176">    }</span>

    /**
     * Returns true if any axis needs to move more than 1 degree.
     *
     * @param mount
     * @param target
     * @return
     */
    private boolean fastSlewRequired(Mount mount, Target target) {
<span class="fc" id="L186">        double decDiff = Math.abs(mount.getDecDegrees() - target.getDec());</span>
<span class="fc" id="L187">        double raDiff = Math.abs(mount.getRaHours() - target.getRaHours());</span>
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">        return decDiff &gt; 1 || raDiff &gt; ONE_DEG_IN_HOURS;</span>
    }

    /**
     * Park will slew the mount to the RA/DEC specified in the {@link Target} and then stop tracking.
     * The mount state is also persisted since this is probably one of the last operations before stopping the application.
     *
     * @param target
     * @return
     */
    @Async
    public Target park(Target target) {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (!mount.isAligned()) {</span>
<span class="nc" id="L201">            mount.setStatusMessage(&quot;Error: Please sync mount before slewing&quot;);</span>
<span class="nc" id="L202">            throw new IllegalStateException(&quot;Please sync/align the mount before moving&quot;);</span>
        }
<span class="fc" id="L204">        LOGGER.warn(&quot;PARKING MOUNT&quot;);</span>
<span class="fc" id="L205">        mount.setTrackingState(TrackingState.PARKING);</span>
<span class="fc" id="L206">        slew(target, true);</span>
<span class="fc" id="L207">        auxAdapter.queueCommand(new SetGuideRate(mount, MountCommand.AZM_BOARD, GuideRate.OFF));</span>
<span class="fc" id="L208">        auxAdapter.queueCommand(new SetGuideRate(mount, MountCommand.ALT_BOARD, GuideRate.OFF));</span>
<span class="fc" id="L209">        auxAdapter.waitForQueueEmpty();</span>
<span class="fc" id="L210">        mount.setTrackingState(TrackingState.PARKED);</span>
<span class="fc" id="L211">        mount.saveState();</span>
<span class="fc" id="L212">        return target;</span>
    }

    /**
     * Unpark will start tracking and sync to the location passed in the Target.
     *
     * @param target
     */
    public void unpark(Target target) {
<span class="fc" id="L221">        LOGGER.info(&quot;Unparking and syncing to {}, {}&quot;, target.getRaHours(), target.getDec());</span>
<span class="fc" id="L222">        startTracking();</span>
<span class="fc" id="L223">        sync(target);</span>
        //TODO: If option set to start PEC on unpark then send pecplayback command here
<span class="fc" id="L225">    }</span>

    /**
     * Start tracking mode depending on the mount's trackingMode. Note: This could also switch off tracking since OFF is a valid guide rate
     */
    public void startTracking() {
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        if (TrackingMode.EQ_NORTH.equals(mount.getTrackingMode())) {</span>
<span class="fc" id="L232">            LOGGER.info(&quot;Starting EQ-NORTH sidereal tracking&quot;);</span>
<span class="fc" id="L233">            auxAdapter.queueCommand(new SetGuideRate(mount, MountCommand.AZM_BOARD, GuideRate.OFF));</span>
<span class="fc" id="L234">            auxAdapter.queueCommand(new SetGuideRate(mount, MountCommand.ALT_BOARD, GuideRate.OFF));</span>
<span class="fc" id="L235">            auxAdapter.queueCommand(new SetGuideRate(mount, MountCommand.AZM_BOARD, mount.getGuideRate()));</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (mount.getGuideRate() == GuideRate.OFF) {</span>
<span class="fc" id="L237">                mount.setTrackingState(TrackingState.IDLE);</span>
            } else {
<span class="fc" id="L239">                mount.setTrackingState(TrackingState.TRACKING);</span>
            }
        } else {
<span class="nc" id="L242">            throw new UnsupportedOperationException(&quot;Currently only EQ north mode is supported.&quot;);</span>
        }
<span class="fc" id="L244">    }</span>

    /**
     * Connect to the mount and enable some default features such as cordwrap.
     *
     * @return
     */
    public boolean connect() {
<span class="fc" id="L252">        mount.setTrackingMode(TrackingMode.EQ_NORTH);</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (!auxAdapter.isConnected()) {</span>
<span class="nc" id="L254">            auxAdapter.setSerialPortName(mount.getSerialPort());</span>
<span class="nc" id="L255">            LOGGER.info(&quot;Starting serial adapter thread&quot;);</span>
<span class="nc" id="L256">            new Thread(auxAdapter).start();</span>
<span class="nc" id="L257">            sleep(1000);//wait for connect</span>
        }
<span class="fc" id="L259">        LOGGER.debug(&quot;Enabling Cordwrap&quot;);</span>
<span class="fc" id="L260">        auxAdapter.queueCommand(new QueryCordWrapPos(mount));</span>
<span class="fc" id="L261">        auxAdapter.queueCommand(new EnableCordWrap(mount));</span>
<span class="fc" id="L262">        auxAdapter.queueCommand(new QueryCordWrap(mount));</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">        if (mount.getTrackingState() == TrackingState.TRACKING) {</span>
<span class="fc" id="L264">            startTracking();</span>
        }
<span class="fc" id="L266">        return true;</span>
    }

    /**
     * Perform a query to the mount to determine current position if connected.
     */
    @Scheduled(fixedDelay = 20000)
    public void queryMountState() {
<span class="fc" id="L274">        mount.setStatusMessage(null);</span>
<span class="fc bfc" id="L275" title="All 4 branches covered.">        if (auxAdapter.isConnected() &amp;&amp; !mount.isSlewing()) {</span>
<span class="pc bpc" id="L276" title="2 of 4 branches missed.">            if (mount.isLocationSet() &amp;&amp; mount.getTrackingMode() != null) {</span>
<span class="fc" id="L277">                LOGGER.debug(&quot;Sending serial queueCommand to query az state&quot;);</span>
<span class="fc" id="L278">                auxAdapter.queueCommand(new QueryAzMcPosition(mount));</span>
<span class="fc" id="L279">                LOGGER.debug(&quot;Sending serial queueCommand to query alt state&quot;);</span>
<span class="fc" id="L280">                auxAdapter.queueCommand(new QueryAltMcPosition(mount));</span>
            }
<span class="fc bfc" id="L282" title="All 4 branches covered.">            if (mount.isGpsInfoOld() &amp;&amp; mount.getTrackingState() != TrackingState.SLEWING) {</span>
<span class="fc" id="L283">                queryGps();</span>
            }
        }
<span class="fc" id="L286">    }</span>

    /**
     * Query the GPS module and update the mount
     */
    private void queryGps() {
<span class="fc" id="L292">        LOGGER.info(&quot;GPS locating satellites&quot;);</span>
<span class="fc" id="L293">        auxAdapter.queueCommand(new GpsLinked(mount));</span>
<span class="fc" id="L294">        auxAdapter.waitForQueueEmpty();</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (mount.isGpsConnected()) {</span>
<span class="fc" id="L296">            LOGGER.info(&quot;GPS connected&quot;);</span>
<span class="fc" id="L297">            auxAdapter.queueCommand(new GpsLat(mount));</span>
<span class="fc" id="L298">            auxAdapter.queueCommand(new GpsLon(mount));</span>
<span class="fc" id="L299">            mount.setLocationSet(true);</span>
<span class="fc" id="L300">            mount.setGpsUpdateTime(new Date());</span>
<span class="fc" id="L301">            LOGGER.info(&quot;GPS location updated&quot;);</span>
        }
<span class="fc" id="L303">    }</span>

    /**
     * Handle a guide request described in the target passed. This call is blocking.
     * Pulse guiding is implemented with a Thread.wait. This is not ideal but I cannot get the pulse guide serial commands to work with my mount
     *
     * @param target
     */
    public void guide(Target target) {
<span class="fc" id="L312">        LOGGER.debug(&quot;Guiding {} {}ms&quot;, target.getMotion(), target.getGuidePulseDurationMs());</span>
<span class="fc" id="L313">        Axis axis = Axis.ALT;</span>
<span class="fc" id="L314">        boolean positive = true;</span>
<span class="fc bfc" id="L315" title="All 4 branches covered.">        if (&quot;east&quot;.equals(target.getMotion()) || &quot;west&quot;.equals(target.getMotion())) {</span>
<span class="fc" id="L316">            axis = Axis.AZ;</span>
        }
<span class="fc bfc" id="L318" title="All 4 branches covered.">        if (&quot;east&quot;.equals(target.getMotion()) || &quot;south&quot;.equals(target.getMotion())) {</span>
<span class="fc" id="L319">            positive = false;</span>
        }
<span class="fc" id="L321">        auxAdapter.queueCommand(new Move(mount, 1, axis, positive));</span>
<span class="fc" id="L322">        sleep(target.getGuidePulseDurationMs().intValue());</span>
<span class="fc" id="L323">        auxAdapter.queueCommand(new Move(mount, 0, axis, positive));</span>
<span class="fc" id="L324">    }</span>

    /**
     * Non blocking call to send motion requests to the scope. The motion will continue until a target with a rate of 0 is passed.
     *
     * @param target
     */
    @Async
    public void moveAxis(Target target) {
<span class="fc" id="L333">        String direction = target.getMotion();</span>
<span class="fc" id="L334">        LOGGER.info(&quot;Motion request {}, {}&quot;, direction, target.getMotionRate());</span>
<span class="fc" id="L335">        Axis axis = Axis.AZ;</span>
<span class="fc bfc" id="L336" title="All 4 branches covered.">        if (&quot;north&quot;.equals(direction) || &quot;south&quot;.equals(direction)) {</span>
<span class="fc" id="L337">            axis = Axis.ALT;</span>
        }
<span class="fc" id="L339">        int rate = 0;</span>
<span class="pc bpc" id="L340" title="1 of 5 branches missed.">        switch (target.getMotionRate()) {</span>
            case 0:
<span class="fc" id="L342">                rate = 1;</span>
<span class="fc" id="L343">                break;</span>
            case 1:
<span class="fc" id="L345">                rate = 3;</span>
<span class="fc" id="L346">                break;</span>
            case 2:
<span class="fc" id="L348">                rate = 6;</span>
<span class="fc" id="L349">                break;</span>
            case 3:
<span class="fc" id="L351">                rate = 9;</span>
                break;
        }
<span class="fc bfc" id="L354" title="All 4 branches covered.">        boolean positive = &quot;north&quot;.equals(direction) || &quot;west&quot;.equals(direction);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (&quot;abort&quot;.equals(direction)) {</span>
<span class="fc" id="L356">            LOGGER.info(&quot;Stopping Motion request {}, {}&quot;, direction, target.getMotionRate());</span>
<span class="fc" id="L357">            auxAdapter.queueCommand(new Move(mount, 0, Axis.ALT, positive));</span>
<span class="fc" id="L358">            auxAdapter.queueCommand(new Move(mount, 0, Axis.AZ, positive));</span>
        } else {
<span class="fc" id="L360">            auxAdapter.queueCommand(new Move(mount, rate, axis, positive));</span>
        }
<span class="fc" id="L362">        queryMountState();</span>
<span class="fc" id="L363">    }</span>


    /**
     * Returns the current known mount state if connected.
     *
     * @return
     */
    public Mount getMount() {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (!auxAdapter.isConnected()) {</span>
<span class="fc" id="L373">            throw new IllegalStateException(&quot;Not Connected&quot;);</span>
        }
<span class="fc" id="L375">        LOGGER.debug(&quot;Getting mount. RA {}, DEC {}&quot;, mount.getRaHours(), mount.getDecDegrees());</span>
<span class="fc" id="L376">        return mount;</span>
    }

    /**
     * Utility method for pulse guiding
     *
     * @param ms
     */
    private void sleep(int ms) {
        try {
<span class="fc" id="L386">            Thread.sleep(ms);</span>
<span class="nc" id="L387">        } catch (InterruptedException e) {</span>
<span class="nc" id="L388">            LOGGER.info(&quot;Sleep interrupted&quot;);</span>
<span class="fc" id="L389">        }</span>
<span class="fc" id="L390">    }</span>

    /**
     * Update the mount. Only 6 properties are updateable. SerialPort, Guiderate, SlewLimits(x2) lat/lon and Pec status
     *
     * @param mountUpdates
     * @return
     */
    @Async
    public void updateMount(Mount mountUpdates) {
<span class="pc bpc" id="L400" title="1 of 4 branches missed.">        if (mountUpdates.getSerialPort() != null &amp;&amp; mountUpdates.getSerialPort() != mount.getSerialPort()) {</span>
<span class="fc" id="L401">            mount.setSerialPort(mountUpdates.getSerialPort());</span>
        }
<span class="pc bpc" id="L403" title="1 of 4 branches missed.">        if (mountUpdates.getGuideRate() != null &amp;&amp; mountUpdates.getGuideRate() != mount.getGuideRate()) {</span>
<span class="fc" id="L404">            mount.setGuideRate(mountUpdates.getGuideRate());</span>
<span class="fc" id="L405">            startTracking();</span>
        }
<span class="pc bpc" id="L407" title="1 of 4 branches missed.">        if (mountUpdates.getSlewLimitAlt() != null &amp;&amp; mountUpdates.getSlewLimitAlt() != mount.getSlewLimitAlt()) {</span>
<span class="fc" id="L408">            mount.setSlewLimitAlt(mountUpdates.getSlewLimitAlt());</span>
        }
<span class="pc bpc" id="L410" title="1 of 4 branches missed.">        if (mountUpdates.getSlewLimitAz() != null &amp;&amp; mountUpdates.getSlewLimitAz() != mount.getSlewLimitAz()) {</span>
<span class="fc" id="L411">            mount.setSlewLimitAz(mountUpdates.getSlewLimitAz());</span>
        }
<span class="pc bpc" id="L413" title="1 of 4 branches missed.">        if (mountUpdates.getPecMode() != null &amp;&amp; mountUpdates.getPecMode() != mount.getPecMode()) {</span>
<span class="fc" id="L414">            startPecOperation(mountUpdates.getPecMode());</span>
        }
<span class="pc bpc" id="L416" title="1 of 4 branches missed.">        if (mountUpdates.getLatitude() != null || mountUpdates.getLongitude() != null) {</span>
<span class="fc" id="L417">            mount.setLongitude(mountUpdates.getLongitude());</span>
<span class="fc" id="L418">            mount.setLatitude(mountUpdates.getLatitude());</span>
<span class="fc" id="L419">            mount.setLocationSet(true);</span>
        }
<span class="fc" id="L421">    }</span>


    /**
     * Start a PEC operation depending on the mount state
     * @param pecMode
     */
    public void startPecOperation(PecMode pecMode) {
<span class="fc" id="L429">        LOGGER.info(&quot;Setting PEC mode to {}&quot;, pecMode);</span>
<span class="pc bpc" id="L430" title="1 of 5 branches missed.">        switch (pecMode) {</span>
            case INDEXING:
<span class="fc" id="L432">                mount.setPecIndexFound(false);</span>
<span class="fc" id="L433">                auxAdapter.queueCommand(new PecSeekIndex(mount));</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">                while (!mount.isPecIndexFound()) {</span>
<span class="fc" id="L435">                    auxAdapter.queueCommand(new PecQueryAtIndex(mount));</span>
<span class="fc" id="L436">                    sleep(pecPollInterval);</span>
                }
                break;
            case RECORDING:
<span class="fc" id="L440">                mount.setPecMode(PecMode.RECORDING);</span>
<span class="fc" id="L441">                auxAdapter.queueCommand(new PecStartRecording(mount));</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">                while (mount.getPecMode().equals(PecMode.RECORDING)) {</span>
<span class="fc" id="L443">                    auxAdapter.queueCommand(new PecQueryRecordDone(mount));</span>
<span class="fc" id="L444">                    sleep(pecPollInterval);</span>
                }
                break;
            case PLAYING:
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                if (mount.getPecMode() == PecMode.RECORDING) {</span>
<span class="nc" id="L449">                    LOGGER.warn(&quot;Mount currently recording, not starting playback&quot;);</span>
                } else {
<span class="fc" id="L451">                    auxAdapter.queueCommand(new PecPlayback(mount, true));</span>
                }
<span class="fc" id="L453">                break;</span>
            case IDLE:
<span class="fc" id="L455">                auxAdapter.queueCommand(new PecStopRecording(mount));</span>
<span class="fc" id="L456">                auxAdapter.queueCommand(new PecPlayback(mount, false));</span>
                break;
        }
<span class="fc" id="L459">    }</span>

    public void setPecPollInterval(int pecPollInterval) {
<span class="fc" id="L462">        this.pecPollInterval = pecPollInterval;</span>
<span class="fc" id="L463">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>